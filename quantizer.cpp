#include <quantizer.h>
#include <utils.h>

namespace avlib {
    const uint8_t default_YQTable[] = {
        0x02, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x05,
        0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x04, 0x04,
        0x03, 0x05, 0x07, 0x06, 0x07, 0x07, 0x07, 0x06,
        0x07, 0x07, 0x08, 0x09, 0x0b, 0x09, 0x08, 0x08,
        0x0a, 0x08, 0x07, 0x07, 0x0a, 0x0d, 0x0a, 0x0a,
        0x0b, 0x0c, 0x0c, 0x0c, 0x0c, 0x07, 0x09, 0x0e,
        0x0f, 0x0d, 0x0c, 0x0e, 0x0b, 0x0c, 0x0c, 0x0c
    };


    const uint8_t default_UQTable[] = {
        0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x06, 0x03,
        0x03, 0x06, 0x0c, 0x08, 0x07, 0x08, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c
    };

    const uint8_t default_VQTable[] = {
        0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x06, 0x03,
        0x03, 0x06, 0x0c, 0x08, 0x07, 0x08, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
        0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c
    };

    CQuant::CQuant() :
        m_q(NULL) {
    }

    CQuant::~CQuant() {
        if(NULL != this->m_q) {
            delete this->m_q;
        }
    }

    void CQuant::setTables(int qp) {
        setTables(default_YQTable, default_UQTable, default_VQTable, qp);
    }

    void CQuant::setTables(const uint8_t *YQ, const uint8_t *UQ, const uint8_t *VQ, int qp) {
        if(NULL == this->m_q) this->m_q = new CImage<float>(CSize(8, 8));
        for(int i = 0; i < 64; i++) {
            (*m_q)[0][0][i] = 1.0f / ((float)YQ[i] * qp);
            (*m_q)[1][0][i] = 1.0f / ((float)UQ[i] * qp);
            (*m_q)[2][0][i] = 1.0f / ((float)VQ[i] * qp);
        }
    }


    void CQuant::TransformBlock(float *pSrc, float *pDst, CPoint p, CSize s) {
        float *src = &pSrc[p.Y * s.Width + p.X];
        float *dst = &pDst[p.Y * s.Width + p.X];
        for(int y = 0; y < (*m_q)[p.Z].getHeight(); y++) {
            for(int x = 0; x < (*m_q)[p.Z].getWidth(); x++) {
                float t = src[y * s.Width + x] * (*m_q)[p.Z][y][x];
                if(!y && !x)  t = LIMIT(t, 2047.0f);
                else	      t = LIMIT(t, 1023.0f);
                dst[y * s.Width + x] = t;
            }
        }
    }


    void CIQuant::TransformBlock(float *pSrc, float *pDst, CPoint p, CSize s) {
        float *src = &pSrc[p.Y * s.Width + p.X];
        float *dst = &pDst[p.Y * s.Width + p.X];
        for(int y = 0; y < (*m_q)[p.Z].getHeight(); y++) {
            for(int x = 0; x < (*m_q)[p.Z].getWidth(); x++) {
                dst[y * s.Width + x] = src[y * s.Width + x] * (*m_q)[p.Z][y][x];
            }
        }
    }

    CIQuant::CIQuant() :
        m_q(NULL) {
    }

    void CIQuant::setTables(int qp) {
        setTables(default_YQTable, default_UQTable, default_VQTable, qp);
    }

    void CIQuant::setTables(const uint8_t *YQ, const uint8_t *UQ, const uint8_t *VQ, int qp) {
        if(NULL == this->m_q) this->m_q = new CImage<float>(CSize(8, 8));
        for(int i = 0; i < 64; i++) {
            (*m_q)[0][0][i] = (float)YQ[i] * qp;
            (*m_q)[1][0][i] = (float)UQ[i] * qp;
            (*m_q)[2][0][i] = (float)VQ[i] * qp;
        }
    }

}
